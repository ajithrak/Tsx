# Writing Interfaces and Types for React Components

## 1. Differences Between `interface` and `type`

### `interface`
- **Definition**: A way to define the shape of an object, typically used for object types or class props.
- **Extensibility**: Can be extended using the `extends` keyword.
- **Use Case**: Best suited for describing the shape of objects, props, or class state.

### `type`
- **Definition**: A more flexible way to define a type, not limited to objects. You can define unions, intersections, primitives, etc.
- **Extensibility**: Cannot be extended directly but can use intersections (`&`) to combine types.
- **Use Case**: Ideal for more complex types, such as unions, tuples, or advanced compositions.

---

### Key Differences

| Feature                | `interface`                           | `type`                                      |
|------------------------|---------------------------------------|--------------------------------------------|
| Extensibility          | Use `extends` for inheritance.        | Use intersections (`&`) to combine types.  |
| Use in Classes         | Works well with classes.              | Cannot directly extend classes.            |
| Advanced Types         | Limited to object shapes.             | Supports primitives, unions, and tuples.   |
| Declaration Merging    | Supported (multiple declarations merge into one). | Not supported.                            |

---

## 2. Writing and Using Interfaces and Types

### With Functional Components

#### Using `interface`

```tsx
interface GroupTourPricingProps {
  pricingType: string;
  selectedCategory: string[];
}

const GroupTourPricing: React.FC<GroupTourPricingProps> = ({ pricingType, selectedCategory }) => {
  return (
    <div>
      <h1>Pricing Type: {pricingType}</h1>
      <ul>
        {selectedCategory.map((category, index) => (
          <li key={index}>{category}</li>
        ))}
      </ul>
    </div>
  );
};

export default GroupTourPricing;
```

#### Using `type`

```tsx
type GroupTourPricingProps = {
  pricingType: string;
  selectedCategory: string[];
};

const GroupTourPricing: React.FC<GroupTourPricingProps> = ({ pricingType, selectedCategory }) => {
  return (
    <div>
      <h1>Pricing Type: {pricingType}</h1>
      <ul>
        {selectedCategory.map((category, index) => (
          <li key={index}>{category}</li>
        ))}
      </ul>
    </div>
  );
};

export default GroupTourPricing;
```

---

### With Class-Based Components

#### Using `interface`

```tsx
import React, { Component } from "react";

interface GroupTourPricingProps {
  pricingType: string;
  selectedCategory: string[];
}

class GroupTourPricing extends Component<GroupTourPricingProps> {
  render() {
    const { pricingType, selectedCategory } = this.props;
    return (
      <div>
        <h1>Pricing Type: {pricingType}</h1>
        <ul>
          {selectedCategory.map((category, index) => (
            <li key={index}>{category}</li>
          ))}
        </ul>
      </div>
    );
  }
}

export default GroupTourPricing;
```

#### Using `type`

```tsx
import React, { Component } from "react";

type GroupTourPricingProps = {
  pricingType: string;
  selectedCategory: string[];
};

class GroupTourPricing extends Component<GroupTourPricingProps> {
  render() {
    const { pricingType, selectedCategory } = this.props;
    return (
      <div>
        <h1>Pricing Type: {pricingType}</h1>
        <ul>
          {selectedCategory.map((category, index) => (
            <li key={index}>{category}</li>
          ))}
        </ul>
      </div>
    );
  }
}

export default GroupTourPricing;
```

---

## 3. Pros and Cons

### `interface`
#### **Pros**:
- **Declaration Merging**: Multiple `interface` declarations with the same name are merged into one.
- **Extensibility**: Simple to extend with `extends`.
- **Preferred for Classes**: Works seamlessly with class components.

#### **Cons**:
- **Limited Features**: Cannot define unions or advanced types.
- **Less Flexible**: Only supports object shapes.

---

### `type`
#### **Pros**:
- **Versatility**: Can define unions, intersections, primitives, tuples, etc.
- **Flexibility**: Ideal for complex types and advanced compositions.
- **Readability**: Often simpler for complex shapes.

#### **Cons**:
- **No Declaration Merging**: Cannot be redefined or merged.
- **Extensibility**: Requires intersections (`&`) for combining types.

---

## 4. Merging Interfaces and Types

You can combine interfaces and types using intersections (`&`):

### Example

```tsx
interface PropsA {
  pricingType: string;
}

type PropsB = {
  selectedCategory: string[];
};

type CombinedProps = PropsA & PropsB;

const GroupTourPricing: React.FC<CombinedProps> = ({ pricingType, selectedCategory }) => {
  return (
    <div>
      <h1>Pricing Type: {pricingType}</h1>
      <ul>
        {selectedCategory.map((category, index) => (
          <li key={index}>{category}</li>
        ))}
      </ul>
    </div>
  );
};

export default GroupTourPricing;
```

---

## 5. Best Practices

1. **Use `interface` for Props and State**:
   - Best suited for simpler object types and extensibility.

2. **Use `type` for Advanced Types**:
   - Use for union types, tuples, or combining multiple types.

3. **When to Choose One**:
   - If you need declaration merging or extensibility, choose `interface`.
   - If you need unions or advanced features, choose `type`.

